Dynamic Programming
--------------------------

1. Overlapping subproblems
	When the solutions to the same subproblems are needed repetitively for solving the actual problem. The problem is said to have overlapping subproblems property.

2. Optimal Substructure Property:
	If the optimal solution of the given problem can be obtained by using optimal solutions of its subproblems then the problem is said to have Optimal Substructure Property.

	Fibonacci Series :-
		-> Using memoization
			Time Complexity -> O(n)
			Space Complexity ->
				O(n)(Recursion Stack)  + O(n) -> array/map => O(n) + O(n) = O(n)

		-> Using Tabulation
			Time Complexity -> O(n)
			Space Complexity -> O(1)



Revision :-
	Largest Sum Contiguous Subarray (Kadane’s Algorithm)
		Given an array arr[] of size N. The task is to find the sum of the contiguous subarray within a arr[] with the largest sum.
		Input :- {-2, -3, 4, -1, -2, 1, 5, -3}

	Algorithm :-
		currentMax = MIN_VALUE;
		interMax = 0; //Out intermediate max should never become negative

		for i -> 0 to n;
			interMax = interMax+ arr[i];

			if(currentMax < interMax) // Check for maximum value here
				currentMax = interMax;

			if(interMax < 0) //ignore negative value;
				interMax = 0;

Find maximum possible stolen value from houses
	There are N houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value of these houses, but he can’t steal in two adjacent houses because the owner of the stolen houses will tell his two neighbors left and right sides. The task is to find what is the maximum stolen value.

	int houseValue[] = {6, 7, 1, 3, 8, 2, 4}
	Output :- 19

	Algorithm:- Recursion
												{6, 7, 1, 3, 8, 2, 4}   	6
		maximumStolenValue -> houseValue[] and noOfHouse

		//case 1:- No houses
		if(n < 0)
			return 0;
		//Case 2: Only one house
		if n == 0
			return houseValue[n];

		int firstPick = houseValue[n] + maximumStolenValue(houseValue, n-2)
		int nextPick = maximumStolenValue(houseValue, n-1)

		int maximumStolenValue = Math.max(firstPick, nextPick);
		return maximumStolenValue;

Knapsack :-
	Knapsack variations
		0/1 knapsack
		fractional knapsack -> greedy approach
		Unbounded knapsack

	Longest Common Subsequence
	Matrix Multiplication

Assignment :-

	A thief needs to rob money in a street. The houses in the street are arranged in a circular manner. Therefore the first and the last house are adjacent to each other. The security system in the street is such that if adjacent houses are robbed, the police will get notified.

	input :- [2, 1, 4, 9]
	output - 10 -> 9+1

	input :- [1, 5, 2, 1, 6]
	output - 11 -> 5+ 6

Knapsack :-
	Knapsack variations
		0/1 knapsack
		fractional knapsack -> greedy approach
		Unbounded knapsack

0/1 knapsack Problems :-
-----------------------------
1. Subset sum problem
2. Equal sum partition
3. Count of subset sum
4. Minimum subset sum diff
5. Target sum
6 Number of subset with given difference.

1. Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.
	Input: set[] = {3, 34, 4, 12, 5, 2}, sum = 9
	Output: True
	There is a subset (4, 5) with sum 9.
	Input: set[] = {3, 34, 4, 12, 5, 2}, sum = 30
	Output: False
	There is no subset that add up to 30. 
	
2. Given an array arr[] of length N and an integer X, the task is to find the number of subsets with a sum equal to X.
	Input: arr[] = {1, 2, 3, 3}, X = 6
	Output: 3
	All the possible subsets are {1, 2, 3},
	{1, 2, 3} and {3, 3}

	Input: arr[] = {1, 1, 1, 1}, X = 1
	Output: 4
	
	
	
	
	
	
	
	
	

Unbounded Knapsack Problems :-
-----------------------------
1. Rod cutting
2. Coin change I
3. Coin change II
4.  Maximum ribbon cut